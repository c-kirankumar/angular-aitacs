<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>BugTracker</title>

    <!--

    Use Case
    --------------

    1. Add a bug - done
    2. list all the bugs - done
    3. toggle the completion status of the bug - done
    4. Remove closed bugs. - done
    5. Display statistics. - done
    6. Search for bugs -- done
    7. Sort the bugs -- done
    8. improvies how the bugs are displayed -- done
    9. persist the bugs in the storage -- done
    window.localStorage
        - key/value store
        - both key and value should be strings
        - apis
        . setItem(key,value)
        . getItem(key) //= > value
        . removeItem(key)
        . key(index)
        . clear()
        . length
        10. display the createdDT of the bugs -- done
        11 persis the bugs in the server
        12 categorize the bugs
        13 view the bugs belong to one particular category
        -->
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>
    <script src="moment.js"></script>
    <script type="text/javascript">

        var bugTracker = angular.module("bugTracker", []);

        bugTracker.value('momentApi', window.moment);

        bugTracker.factory('Bug', function () {
            function Bug(defaults) {
                defaults = defaults || {};
                this.name = defaults.name || "";
                this.isClosed = defaults.isClosed || false;
                this.id = defaults.id || 0;
                this.createdAt = defaults.createdAt || new Date();
            }

            Bug.prototype.toggle = function () {
                this.isClosed = !this.isClosed;
            }
            return Bug;
        });

        bugTracker.filter('toMoment', function (momentApi) {
            return function (date) {
                return momentApi(date).fromNow();
            }
        })

        //bugTracker.factory('BugService', function (Bug) {

        //    var storage = window.localStorage;
        //    var maxId = 0;

        //    function getAll() {
        //        var bugs = [];
        //        for (let i = 0; i < storage.length; i++) {
        //            var key = storage.key(i);
        //            maxId = parseInt(key) > maxId ? parseInt(key) : maxId;
        //            var bugData = storage.getItem(key);
        //            bugJson = angular.fromJson(bugData);
        //            bugs.push(new Bug(bugJson));
        //        }
        //        return bugs;
        //    }

        //    function addBug(bug) {
        //        bug.id = ++maxId;
        //        storage.setItem(bug.id, angular.toJson(bug));
        //        return bug;
        //    }

        //    function updateBug(bug) {
        //        storage.setItem(bug.id, angular.toJson(bug));
        //    }

        //    function removeBug(bug) {
        //        storage.removeItem(bug.id);
        //    }


        //    return {
        //        getAll: getAll,
        //        addBug: addBug,
        //        updateBug: updateBug,
        //        removeBug: removeBug
        //    }
        //});


        bugTracker.service('BugService', function (Bug) {

            var storage = window.localStorage;
            var maxId = 0;

            this.getAll = function () {
                var bugs = [];
                for (let i = 0; i < storage.length; i++) {
                    var key = storage.key(i);
                    maxId = parseInt(key) > maxId ? parseInt(key) : maxId;
                    var bugData = storage.getItem(key);
                    bugJson = angular.fromJson(bugData);
                    bugs.push(new Bug(bugJson));
                }
                return bugs;
            }

            this.addBug = function (bug) {
                bug.id = ++maxId;
                storage.setItem(bug.id, angular.toJson(bug));
                return bug;
            }

            this.updateBug = function (bug) {
                storage.setItem(bug.id, angular.toJson(bug));
            }

            this.removeBug = function (bug) {
                storage.removeItem(bug.id);
            }

        });

        bugTracker.controller("bugController", function ($scope, Bug, BugService) {

            $scope.name = "";
            var bugs = BugService.getAll();
            $scope.bugs = bugs;
            $scope.addBug = function () {
                var bug = BugService.addBug(new Bug({ name: $scope.name, isClosed: false }));
                $scope.bugs.push(bug);
            };

            $scope.toggle = function (bug) {
                bug.toggle();
                BugService.updateBug(bug);
            }

            $scope.removeClosedBug = function () {
                for (var i = $scope.bugs.length - 1; i >= 0; i--) {
                    if ($scope.bugs[i].isClosed) {
                        BugService.removeBug($scope.bugs[i])
                        $scope.bugs.splice(i, 1);

                    }
                }
            };


            //$scope.getClosedBugCount = function () {

            //    return $scope.bugs.reduce(function (counter, bug) {
            //        return bug.isClosed ? ++counter : counter;
            //    }, 0);
            //}

        });

        bugTracker.filter('closedCount', function ($filter) {

            var builtInFilter = $filter('filter');
            return function (bugs) {
                return builtInFilter(bugs, { isClosed: true }).length;
                //return bugs.reduce(function (counter, bug) {
                //    return bug.isClosed ? ++counter : counter;
                //}, 0);
            }
        });

        bugTracker.value('defaultTrimText', '20');

        bugTracker.filter('trimText', function (defaultTrimText) {

            return function (text, length) {
                length = length || defaultTrimText;
                return text.length > parseInt(length) ? text.substr(0, parseInt(length)) + '..' : text;
            }
        });



    </script>

    <style>
        .closedCount {
            color: red;
        }

        .closed {
            text-decoration: line-through;
            font-style: italic;
            color: red;
        }

        .filterBug, .statistics, .listBugs, .sortBug {
            padding: 10px;
        }

        .moment {
            font-style: italic;
            color: black;
        }
    </style>
</head>


<body ng-app="bugTracker" ng-controller="bugController">

    <h2> Bug Tracker application </h2>
    <div class="statistics"><span class="closedCount"> {{ bugs | closedCount}}</span>/ {{bugs.length}}</div>
    <div class="createBug">
        <span> New Bug</span> <input type="text" ng-model="name" id="txtName" /> <input type="button" ng-click="addBug()" value="Add Bug" /> <input type="button" value="Remove closed bug" ng-click="removeClosedBug()" />

    </div>

    <div class="filterBug">
        <span> Criteria: </span> <input type="text" ng-model="searchbug.name" id="txtSearch" /> <span>Closed Bugs </span> <input type="checkbox" ng-model="searchbug.isClosed" /> <input type="button" value="Show All" ng-click="searchbug=undefined" />

    </div>

    <div class="sortBug">
        Order By : <input type="text" name="txtOrder" ng-model="orderBy" /> <label>isDecending</label> <input type="checkbox" name="" ng-model="isDescending" />
    </div>

    <div class="listBugs">
        <ol>
            <li ng-repeat="bug in bugs | filter:searchbug | orderBy: orderBy :isDescending"
                ng-class="{closed: bug.isClosed}"
                ng-click="toggle(bug)">{{bug.name | trimText}} -<span class="moment">{{bug.createdAt | toMoment}}</span></li>
        </ol>
    </div>
</body>
</html>
